package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"os"
	"time"

	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

var host string
var email string
var apiKey string

var DBFileName = "zulip.db"

func main() {
	if len(os.Args) < 3 {
		log.Fatalf("Expected at least two args: %s <host> <email> [<password>]\nPassword can optionally be set in local environment as API_KEY", os.Args[0])
	}
	host = os.Args[1]
	email = os.Args[2]

	if len(os.Args) > 3 {
		apiKey = os.Args[3]
	} else {
		apiKey = os.Getenv("API_KEY")
		if apiKey == "" {
			log.Fatalf("Missing API_KEY either as third parameter or as API_KEY environment variable")
		}
	}

	// Check database file doesn't already exist
	if _, err := os.Stat(DBFileName); err == nil {
		log.Fatalf("'%s aleady exists!", DBFileName)
	}

	// Open database
	db, err := gorm.Open(sqlite.Open(DBFileName), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}

	db.AutoMigrate(&Stream{})
	// db.AutoMigrate(&Topic{})
	db.AutoMigrate(&Message{})

	streams, err := getStreams()
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("Found %d streams", len(streams))

	for _, s := range streams {
		err = db.Create(&s).Error
		if err != nil {
			log.Fatal(err)
		}
		log.Printf("Processing stream %s\n", s.Name)
		topics, err := getStreamTopics(s.StreamID)
		if err != nil {
			log.Fatal(err)
		}
		for _, t := range topics {
			// err = db.Create(&t).Error
			if err != nil {
				log.Fatal(err)
			}
			log.Printf("Getting messages for '%s: %s':\n", s.Name, t.Name)
			err := GetStreamTopicMessagesCB(s.Name, t.Name, func(messages []Message) error {
				for _, message := range messages {
					err = db.Create(&message).Error
					if err != nil {
						return err
					}
				}
				log.Printf(" - fetched %d messages", len(messages))
				return nil
			})
			if err != nil {
				log.Fatal(err)
			}
		}
	}
}

func getStreams() ([]Stream, error) {
	result, err := zulipGet("/api/v1/streams")
	if err != nil {
		return nil, err
	}
	return result.Streams, nil
}

func getStreamTopics(StreamID uint) ([]Topic, error) {
	result, err := zulipGet(fmt.Sprintf("/api/v1/users/me/%d/topics", StreamID))
	if err != nil {
		return nil, err
	}
	return result.Topics, nil
}

func GetStreamTopicMessagesCB(Stream string, Topic string, CallBack func([]Message) error) error {
	anchor := uint(0)
	numBefore := 0
	numAfter := 500

	path := "/api/v1/messages?"

	// Repeatedly gets messages for given stream/topic until none left to fetch
	// We could actually just get all messages for all streams/topic...
	for {
		q := url.Values{}
		q.Add("anchor", fmt.Sprintf("%d", anchor))
		q.Add("num_before", fmt.Sprintf("%d", numBefore))
		q.Add("num_after", fmt.Sprintf("%d", numAfter))
		q.Add("narrow", fmt.Sprintf(`[{"negated":false,"operator":"stream","operand":"%s"},{"negated":false,"operator":"topic","operand":"%s"}]`,
			Stream, Topic))

		url := path + q.Encode()
		// log.Println(url)
		result, err := zulipGet(url)
		if err != nil {
			return err
		}
		if len(result.Messages) == 0 {
			break
		}
		anchor = result.Messages[len(result.Messages)-1].MessageID + 1
		err = CallBack(result.Messages)
		if err != nil {
			return err
		}
		time.Sleep(time.Second)
	}

	return nil
}

type Stream struct {
	StreamID    uint   `json:"stream_id" gorm:"primaryKey"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

type Topic struct {
	MaxID uint   `json:"max_id"`
	Name  string `json:"name" gorm:"unique"`
}

type Message struct {
	MessageID      uint   `json:"id" gorm:"primaryKey"`
	Timestamp      uint   `json:"timestamp"`
	Content        string `json:"content"`
	ContentType    string `json:"content_type"`
	AvatarUrl      string `json:"avatar_url"`
	Client         string `json:"client"`
	SenderEmail    string `json:"sender_email"`
	SenderFullName string `json:"sender_full_name"`
	SenderID       uint   `json:"sender_id"`
	StreamID       uint   `json:"stream_id"`
	Subject        string `json:"subject"`
}

/*
Message fields not added
display_recipient: Data on the recipient of the message; either the name of a stream or a dictionary containing data on the users who received the message.
flags: The user's message flags for the message.
reactions: Data on any reactions to the message.
recipient_id: A unique ID for the set of users receiving the message (either a stream or group of users). Useful primarily for hashing.
sender_id: The user ID of the message's sender.
sender_realm_str: A string identifier for the realm the sender is in.
sender_short_name: Reserved for future use.
subject_links: Data on any links to be included in the topic line (these are generated by custom linkification filters that match content in the message's topic.)
*/

type Result struct {
	Result   string    `json:"result"`
	Streams  []Stream  `json:"streams"`
	Topics   []Topic   `json:"topics"`
	Messages []Message `json:"messages"`
}

func zulipGet(path string) (result *Result, err error) {

	url := "https://" + host + path
	ctx, _ := context.WithTimeout(context.Background(), time.Minute)
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return
	}
	req.SetBasicAuth(email, apiKey)

	ret, err := http.DefaultClient.Do(req)
	if err != nil {
		return
	}

	defer ret.Body.Close()

	if ret.StatusCode != 200 {
		return nil, errors.New(ret.Status)
	}

	dec := json.NewDecoder(ret.Body)

	err = dec.Decode(&result)
	if err != nil {
		return
	}

	return
}
